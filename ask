#!/usr/bin/env python3
# -*- coding:utf8 -*-

import sys
import os
import string

import preprocess as st
from predicate_framework import Predicate, PredicateFinder
from question import Question

import pprint as pprint

pp = pprint.PrettyPrinter()

class QuestionGenerator:

    def __init__(self, doc):
        pf = PredicateFinder()
        self.predicates = pf.find_predicates(doc)

    def generateWhQuestions(self):
        output = []

        for pred in self.predicates:

            # FIXME: patch to prevent errors. 
            # should invalidate predicates without verbs
            # and have a case for predicates with no objects.
            if len(pred.verb) > 0 and pred.obj is not None and pred.subj is not None:

                # make questions where answer is sentence subject
                # getting last index of verb list *probably* gets the most operant verb
                if pred.verb[-1].lemma_ == 'be':
                    output.append(self.existential_q_from(pred))
                
                # make questions where answer is sentence object
                output.append(self.simple_predicate_q_from(pred))

        # set to remove duplicates, list to remain subscriptable
        return list(set(output))

    def generate_existential_questions(self):
        output = []
        
        return output
        
    def existential_q_from(self, predicate):
        vp = ' '.join([verb.text.strip() for verb in predicate.verb])
        subj = predicate.subj.text.strip()
        wh_word = predicate.wh_word
        obj = predicate.obj.text.strip()

        raw_q = ' '.join([wh_word, vp, subj]) + '?'

        return Question(raw_q, wh_word.upper(), obj)

    def simple_predicate_q_from(self, predicate):
        vp = ' '.join([verb.text.strip() for verb in predicate.verb])
        subj = predicate.subj.text.strip()
        wh_word = predicate.wh_word
        obj = predicate.obj.text.strip()

        raw_q = ' '.join([wh_word, vp, obj]) + '?'

        return Question(raw_q, wh_word.upper(), subj)

    # def generateEntityWhQuestion(self, coref_cluster):
    #     entity = coref_cluster.main

    #     # TODO: get right plurality
    #     # TODO: truecasing (see https://towardsdatascience.com/truecasing-in-natural-language-processing-12c4df086c21)
    #     #       for now, just using .title() to capitalize every word

    #     # entity[0] gives token, so can call ent_type_
    #     wh_word = self.replaceWhSubject(entity[0])

    #     if wh_word: 
    #         return (wh_word + ' is ' + entity.text.title() + "?")
        
    #     return None
    
    def generateWhObjQuestion(self, chunk, subject):
        wh_word = self.replaceWhSubject(subject)
        if not wh_word: wh_word = "What" # default

        # change 'to be' inflection for plural words
        # spacy.Token.tag denotes plural words with a final 'S'
        if chunk.root.tag_.endswith('S'):
            linking_verb = 'are'
        else:
            linking_verb = 'is'

        # only capitalize proper names
        # using non-null entity types as a proxy
        if chunk.root.ent_type_ == '':
            text = chunk.text.lower()
        else:
            text = chunk.text

        return wh_word + ' ' + linking_verb + " " + text + "?"

    def compileQuestionString(self, lst):
        output = lst[0]

        num_quotes = 0

        no_space_after = set(['$', '(', '[', '{', '-'])

        no_space_before = set(string.punctuation) - set(['$', '(', '[', '{', '"'])

        for i in range(1, len(lst)):
            token = lst[i]
            last = lst[i-1]

            if token == '"':
                num_quotes += 1

                if num_quotes % 2 != 0:
                    output += ' '

            elif last not in no_space_after and token[0] not in no_space_before:
                if last != '"' or num_quotes% 2 == 0:
                    output += ' '

            output += token


        if output[-1] not in ['"', "'"] and output[-1] in string.punctuation:
            output = output[:-1]

        output += '?'

        return output

def blockPrint():
    sys.stdout = open(os.devnull, 'w')

def enablePrint():
    sys.stdout = sys.__stdout__

if __name__ == "__main__":
    # Suppress printing until we show output
    # REMOVE THIS IF YOU'RE HAVING PROBLEMS
    blockPrint()

    # Ensure 2 arguments
    if len(sys.argv) != 3:
        print("Usage: ./ask ARTICLE_TXT NUM_QUESTIONS")
        sys.exit(1)

    # Read string from 1 text file. 
    # TODO: extend this to a directory of files
    INPUT_TXT = sys.argv[1]

    # validate that n_questions is an integer
    if not sys.argv[2].isdigit():
        print("NUM_QUESTIONS must be an integer")
        sys.exit(1)

    N_QUESTIONS = int(sys.argv[2])

    with open(INPUT_TXT, 'r') as file:
        text = file.read()

    # Instantiate our preprocessor and get the processed doc
    preprocessor = st.Preprocessor(text)
    processed_doc = preprocessor.doc

    enablePrint()

    # Instantiate our question generator and make some questions
    question_generator = QuestionGenerator(processed_doc)

    wh_questions = question_generator.generateWhQuestions()
    # for i in range(N_QUESTIONS):
    #     j = i % len(wh_questions)
    #     print(wh_questions[j])
    
    # debug line; remove for prod
    print()
    for question in wh_questions: 
        print(question.q_string)
        print(question.q_class)
        print(question.q_answer)
        print()
