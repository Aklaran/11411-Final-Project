#!/usr/bin/env python3
# -*- coding:utf8 -*-

import sys
import os
import string

import preprocess as st

import pprint as pprint

PRED_PATTERN = ['NP', 'VP', '.']

pp = pprint.PrettyPrinter()

class QuestionGenerator:

    def generateWhQuestions(self, doc):
        predicates = []

        for sent in doc.sents:
            more_preds = self.find_predicates([], sent)
            predicates.extend(more_preds)

        pp.pprint(predicates)
        print(len(predicates))

        # set to remove duplicates, list to remain subscriptable
        # return list(set(output))
    
    def find_predicates(self, predicates, root):
        # base case (also checked at every level)
        if self.is_predicate(root):
            predicates.append(root)

        # recursive case - check children for predicates
        for child in root._.children:
            self.find_predicates(predicates, child)
        
        return predicates
    
    def is_predicate(self, sentence):

        for i, child in enumerate(sentence._.children):

            # handle empty label case
            if len(child._.labels) == 0:
                # if in final pos, check for period (periods have empty labels)
                if i == len(PRED_PATTERN) - 1:
                    return child.text in ['.', ',', ';', ':']

                # otherwise it's just out of place
                return False

            if child._.labels[0] != PRED_PATTERN[i]:
               return False

        # has no children - not a predicate
        return False


    def generateEntityWhQuestion(self, coref_cluster):
        entity = coref_cluster.main

        # TODO: get right plurality
        # TODO: truecasing (see https://towardsdatascience.com/truecasing-in-natural-language-processing-12c4df086c21)
        #       for now, just using .title() to capitalize every word

        # entity[0] gives token, so can call ent_type_
        wh_word = self.replaceWhSubject(entity[0])

        if wh_word: 
            return (wh_word + ' is ' + entity.text.title() + "?")
        
        return None
    
    def generateWhObjQuestion(self, chunk, subject):
        wh_word = self.replaceWhSubject(subject)
        if not wh_word: wh_word = "What" # default

        # change 'to be' inflection for plural words
        # spacy.Token.tag denotes plural words with a final 'S'
        if chunk.root.tag_.endswith('S'):
            linking_verb = 'are'
        else:
            linking_verb = 'is'

        # only capitalize proper names
        # using non-null entity types as a proxy
        if chunk.root.ent_type_ == '':
            text = chunk.text.lower()
        else:
            text = chunk.text

        return wh_word + ' ' + linking_verb + " " + text + "?"

    def replaceWhSubject(self, subj):
        # dictionary to map from entity types to wh- pronouns
        switcher = {
            'PERSON': 'Who',
            'GPE': 'What',
            'LOC': 'Where',
            'ORG': 'What',
            'FC': 'What',
            'EVENT': 'What',
            'WORK_OF_ART': 'What',
        }

        return switcher.get(subj.ent_type_, None)

    def compileQuestionString(self, lst):
        output = lst[0]

        num_quotes = 0

        no_space_after = set(['$', '(', '[', '{', '-'])

        no_space_before = set(string.punctuation) - set(['$', '(', '[', '{', '"'])

        for i in range(1, len(lst)):
            token = lst[i]
            last = lst[i-1]

            if token == '"':
                num_quotes += 1

                if num_quotes % 2 != 0:
                    output += ' '

            elif last not in no_space_after and token[0] not in no_space_before:
                if last != '"' or num_quotes% 2 == 0:
                    output += ' '

            output += token


        if output[-1] not in ['"', "'"] and output[-1] in string.punctuation:
            output = output[:-1]

        output += '?'

        return output

def blockPrint():
    sys.stdout = open(os.devnull, 'w')

def enablePrint():
    sys.stdout = sys.__stdout__

if __name__ == "__main__":
    # Suppress printing until we show output
    # REMOVE THIS IF YOU'RE HAVING PROBLEMS
    blockPrint()

    # Ensure 2 arguments
    if len(sys.argv) != 3:
        print("Usage: ./ask ARTICLE_TXT NUM_QUESTIONS")
        sys.exit(1)

    # Read string from 1 text file. 
    # TODO: extend this to a directory of files
    INPUT_TXT = sys.argv[1]

    # validate that n_questions is an integer
    if not sys.argv[2].isdigit():
        print("NUM_QUESTIONS must be an integer")
        sys.exit(1)

    N_QUESTIONS = int(sys.argv[2])

    with open(INPUT_TXT, 'r') as file:
        text = file.read()

    # Instantiate our preprocessor and get the processed doc
    preprocessor = st.Preprocessor(text)
    processed_doc = preprocessor.doc

    enablePrint()

    # Instantiate our question generator and make some questions
    question_generator = QuestionGenerator()

    wh_questions = question_generator.generateWhQuestions(processed_doc)
    for i in range(N_QUESTIONS):
        j = i % len(wh_questions)
        print(wh_questions[j])
    
    # debug line; remove for prod
    print()
    for question in wh_questions: 
        print(question)
